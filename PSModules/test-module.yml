parameters:
- name: ModuleName
  type: string

stages:
- stage: Test
  dependsOn: Build
  jobs:
    - job: Test
      steps:
        # https://github.com/PoshCode/Azure-Pipelines/blob/master/Install-RequiredModule-step.yml
        - powershell: |
            # Apparently, Install-Script isn't good enough except on Windows?
            # Install-Script Install-RequiredModule -Force -Verbose
            Save-Script Install-RequiredModule -Path '$(Pipeline.Workspace)'
            &"$(Pipeline.Workspace)/Install-RequiredModule" -Path '$(Build.SourcesDirectory)/RequiredModules.psd1' -Confirm:$false -Verbose
            foreach ($installErr in $IRM_InstallErrors) {
                Write-Warning "ERROR: $installErr"
                Write-Warning "STACKTRACE: $($installErr.ScriptStackTrace)"
            }
          displayName: 'Restore pre-requisites'
      - task: DownloadPipelineArtifact@2
        inputs:
          artifactName: ${{ parameters.ModuleName }}
          targetPath: $(Build.ArtifactStagingDirectory)
      - powershell: |
          @"
          function Measure-UnicodeSubstitutions {
              <#
          .SYNOPSIS
              Does not contain unicode versions of dashes and hyphens
          .DESCRIPTION
              When copying code from the internet, sometimes quotes and hyphens are replaced with unicode characters
              To fix this, replace the characters with "standard" characters
          .EXAMPLE
              Measure-RequiresRunAsAdministrator -ScriptBlockAst $ScriptBlockAst
          .INPUTS
              [System.Management.Automation.Language.ScriptBlockAst]
          .OUTPUTS
              [Microsoft.Windows.PowerShell.ScriptAnalyzer.Generic.DiagnosticRecord[]]
          .NOTES
              None
          #>
              [CmdletBinding()]
              [OutputType([Microsoft.Windows.PowerShell.ScriptAnalyzer.Generic.DiagnosticRecord[]])]
              Param
              (
                  [Parameter(Mandatory = $true)]
                  [ValidateNotNullOrEmpty()]
                  [System.Management.Automation.Language.ScriptBlockAst]
                  $ScriptBlockAst
              )

              Process {
                  $results = @()
                  [ScriptBlock]$predicate = {
                      param ( $ast )

                      if ($ast -is [System.Management.Automation.Language.BinaryExpressionAst] -or
                          $ast -is [System.Management.Automation.Language.CommandParameterAst] -or
                          $ast -is [System.Management.Automation.Language.AssignmentStatementAst] -or
                          $ast -is [System.Management.Automation.Language.UnaryExpressionAst] -or
                          $ast -is [System.Management.Automation.Language.ConstantExpressionAst]) {

                          if ($ast.Extent.Text[0] -in 0x2013, 0x2014, 0x2015) {
                              return $true
                          }
                      }

                      if (($ast -is [System.Management.Automation.Language.UnaryExpressionAst] -or
                              $ast -is [System.Management.Automation.Language.BinaryExpressionAst]) -and
                          $ast.Extent.Text -match '\u2013|\u2014|\u2015') {
                          return $true
                      }

                      if ($ast -is [System.Management.Automation.Language.CommandAst] -and
                          $ast.GetCommandName() -match '\u2013|\u2014|\u2015') {
                          return $true
                      }

                      if (($ast -is [System.Management.Automation.Language.StringConstantExpressionAst] -or
                              $ast -is [System.Management.Automation.Language.ExpandableStringExpressionAst]) -and
                          (($ast.Parent -is [System.Management.Automation.Language.CommandExpressionAst]) -or
                              $ast.Parent -is [System.Management.Automation.Language.BinaryExpressionAst])) {
                          if ($ast.Parent -match '^[\u2018-\u201e]|[\u2018-\u201e]$') {
                              return $true
                          }
                      }
                  }
                  #endregion
                  #region Finds ASTs that match the predicates.

                  [System.Management.Automation.Language.Ast[]]$elements = $ScriptBlockAst.FindAll($predicate, $true)

                  foreach ($element in $elements) {
                      $result = [Microsoft.Windows.PowerShell.ScriptAnalyzer.Generic.DiagnosticRecord]@{
                          'Message'  = "Bad unicode characters"
                          'Extent'   = $element.Extent
                          'RuleName' = $PSCmdlet.MyInvocation.InvocationName
                          'Severity' = 'Error'
                      }
                      $results += $result
                  }

                  return $results
                  #endregion
              }
          }
          "@ | Set-Content "$(Build.SourcesDirectory)\Tests\CustomRules.psm1"
          Set-Content "$(Build.SourcesDirectory)\Tests\PSScriptAnalzyer.Tests.ps1" '$Path = "$(Build.ArtifactStagingDirectory)"

          Import-Module "$(Build.ArtifactStagingDirectory)\${{ parameters.ModuleName }}"

          Describe "PSScriptAnalyzer" {
            $ScriptAnalyzer = @{
              Config = @{ Path = $Path; Recurse = $true; IncludeDefaultRules = $true }
              Rules = Get-ScriptAnalyzerRule
            }

            It "Can have custom rules" {
              "$(Build.SourcesDirectory)\Tests\CustomRules.psm1" | Should Exist
              if ($CustomRules = Get-ScriptAnalyzerRule -CustomRulePath "$(Build.SourcesDirectory)\Tests\CustomRules.psm1" -RecurseCustomRulePath) {
              $ScriptAnalyzer.Rules += $CustomRules
              $ScriptAnalyzer.Config += @{
                  CustomRulePath        = "$(Build.SourcesDirectory)\Tests\CustomRules.psm1"
                  RecurseCustomRulePath = $true
              }
              }

            }

            It "Does not throw while running Script Analyzer" {
              $Config = $ScriptAnalyzer.Config
              try {
                $ScriptAnalyzer.Results = Invoke-ScriptAnalyzer @Config
              } catch {
                Write-Warning "Exception running script analyzer on $($_.TargetObject)"
                Write-Warning $($_.Exception.StackTrace)
                throw
              }
            }

            forEach ($Rule in $ScriptAnalyzer.Rules.RuleName) {
              It "Passes $Rule" {
                if ($Failures = $ScriptAnalyzer.Results.Where( {$_.RuleName -like "*$Rule"})) {
                  throw ([Management.Automation.ErrorRecord]::new(
                    ([Exception]::new(($Failures.ForEach{$_.ScriptName + ":" + $_.Line + " " + $_.Message} -join "`n"))),
                    "ScriptAnalyzerViolation",
                    "SyntaxError",
                    $Failures))
                }
              }
            }
          }
          '

      - powershell: |
          Import-Module Pester

          $Options = @{
              Path = Convert-Path "$(Build.SourcesDirectory)\Tests"
              OutputFormat = "NUnitXml"
              OutputFile = Join-Path '$(Common.TestResultsDirectory)' 'Test-$(Build.SourceVersion).xml'
          }

          if ($CodeCoverage = "$(Build.ArtifactStagingDirectory)") {
              $Options.CodeCoverage = Get-ChildItem $CodeCoverage -Recurse -Include *.psm1, *.ps1 | Convert-Path
              $Options.CodeCoverageOutputFile = '$(Common.TestResultsDirectory)/Coverage-$(Build.SourceVersion).xml'
          }

          Write-Host $($Options | Out-String)
          if (!$PSVersionTable.OS) {
              $PSVersionTable.OS = [System.Environment]::OSVersion
          }

          Write-Host "##vso[task.setvariable variable=PSPlatform]PowerShell $($PSVersionTable['PSVersion', 'OS'] -join ' on ')"
          Invoke-Pester @Options
      - task: PublishCodeCoverageResults@1
        displayName: Publish Code Coverage
        inputs:
          summaryFileLocation: '$(Common.TestResultsDirectory)/Coverage-$(Build.SourceVersion).xml'
          pathToSources: $(CodeCoverageRecurseDirectories)
          #failIfCoverageEmpty: true
        condition: succeededOrFailed()
      - task: PublishTestResults@2
        displayName: Publish Test Results
        inputs:
          testResultsFormat: NUnit
          testResultsFiles: '$(Common.TestResultsDirectory)/Test-$(Build.SourceVersion).xml'
          buildPlatform: $(PSPlatform)
          #buildConfiguration: ${{ parameters.configurationName }}
          failTaskOnFailedTests: true
          testRunTitle: "Pester on $(PSPlatform)"
        condition: succeededOrFailed()
