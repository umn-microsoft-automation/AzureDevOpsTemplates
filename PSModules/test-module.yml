parameters:
- name: ModuleName
  type: string

stages:
- stage: Test
  jobs:
    - job: Test
      steps:
      - checkout: none
      - task: DownloadPipelineArtifact@2
        inputs:
          artifactName: ${{ parameters.ModuleName }}
          targetPath: $(Build.ArtifactStagingDirectory)
      - powershell: |
          @"
          function Measure-UnicodeSubstitutions {
              <#
          .SYNOPSIS
              Does not contain unicode versions of dashes and hyphens
          .DESCRIPTION
              When copying code from the internet, sometimes quotes and hyphens are replaced with unicode characters
              To fix this, replace the characters with "standard" characters
          .EXAMPLE
              Measure-RequiresRunAsAdministrator -ScriptBlockAst $ScriptBlockAst
          .INPUTS
              [System.Management.Automation.Language.ScriptBlockAst]
          .OUTPUTS
              [Microsoft.Windows.PowerShell.ScriptAnalyzer.Generic.DiagnosticRecord[]]
          .NOTES
              None
          #>
              [CmdletBinding()]
              [OutputType([Microsoft.Windows.PowerShell.ScriptAnalyzer.Generic.DiagnosticRecord[]])]
              Param
              (
                  [Parameter(Mandatory = $true)]
                  [ValidateNotNullOrEmpty()]
                  [System.Management.Automation.Language.ScriptBlockAst]
                  $ScriptBlockAst
              )

              Process {
                  $results = @()
                  [ScriptBlock]$predicate = {
                      param ( $ast )

                      if ($ast -is [System.Management.Automation.Language.BinaryExpressionAst] -or
                          $ast -is [System.Management.Automation.Language.CommandParameterAst] -or
                          $ast -is [System.Management.Automation.Language.AssignmentStatementAst] -or
                          $ast -is [System.Management.Automation.Language.UnaryExpressionAst] -or
                          $ast -is [System.Management.Automation.Language.ConstantExpressionAst]) {

                          if ($ast.Extent.Text[0] -in 0x2013, 0x2014, 0x2015) {
                              return $true
                          }
                      }

                      if (($ast -is [System.Management.Automation.Language.UnaryExpressionAst] -or
                              $ast -is [System.Management.Automation.Language.BinaryExpressionAst]) -and
                          $ast.Extent.Text -match '\u2013|\u2014|\u2015') {
                          return $true
                      }

                      if ($ast -is [System.Management.Automation.Language.CommandAst] -and
                          $ast.GetCommandName() -match '\u2013|\u2014|\u2015') {
                          return $true
                      }

                      if (($ast -is [System.Management.Automation.Language.StringConstantExpressionAst] -or
                              $ast -is [System.Management.Automation.Language.ExpandableStringExpressionAst]) -and
                          (($ast.Parent -is [System.Management.Automation.Language.CommandExpressionAst]) -or
                              $ast.Parent -is [System.Management.Automation.Language.BinaryExpressionAst])) {
                          if ($ast.Parent -match '^[\u2018-\u201e]|[\u2018-\u201e]$') {
                              return $true
                          }
                      }
                  }
                  #endregion
                  #region Finds ASTs that match the predicates.

                  [System.Management.Automation.Language.Ast[]]$elements = $ScriptBlockAst.FindAll($predicate, $true)

                  foreach ($element in $elements) {
                      $result = [Microsoft.Windows.PowerShell.ScriptAnalyzer.Generic.DiagnosticRecord]@{
                          'Message'  = "Bad unicode characters"
                          'Extent'   = $element.Extent
                          'RuleName' = $PSCmdlet.MyInvocation.InvocationName
                          'Severity' = 'Error'
                      }
                      $results += $result
                  }

                  return $results
                  #endregion
              }
          }
          "@ | Set-Content .\Tests\CustomRules.psm1
          Set-Content ".\Tests\PSScriptAnalzyer.Tests.ps1" '$Path = "$(Build.ArtifactStagingDirectory)"

          Import-Module "$(Build.ArtifactStagingDirectory)\${{ parameters.ModuleName }}"

          Describe "PSScriptAnalyzer" {
            $ScriptAnalyzer = @{
              Config = @{ Path = $Path; Recurse = $true; IncludeDefaultRules = $true }
              Rules = Get-ScriptAnalyzerRule
            }

            It "Can have custom rules" {
              ".\Tests\CustomRules.psm1" | Should Exist
              if ($CustomRules = Get-ScriptAnalyzerRule -CustomRulePath ".\Tests\CustomRules.psm1" -RecurseCustomRulePath) {
              $ScriptAnalyzer.Rules += $CustomRules
              $ScriptAnalyzer.Config += @{
                  CustomRulePath        = ".\Tests\CustomRules.psm1"
                  RecurseCustomRulePath = $true
              }
              }

            }

            It "Does not throw while running Script Analyzer" {
              $Config = $ScriptAnalyzer.Config
              try {
                $ScriptAnalyzer.Results = Invoke-ScriptAnalyzer @Config
              } catch {
                Write-Warning "Exception running script analyzer on $($_.TargetObject)"
                Write-Warning $($_.Exception.StackTrace)
                throw
              }
            }

            forEach ($Rule in $ScriptAnalyzer.Rules.RuleName) {
              It "Passes $Rule" {
                if ($Failures = $ScriptAnalyzer.Results.Where( {$_.RuleName -like "*$Rule"})) {
                  throw ([Management.Automation.ErrorRecord]::new(
                    ([Exception]::new(($Failures.ForEach{$_.ScriptName + ":" + $_.Line + " " + $_.Message} -join "`n"))),
                    "ScriptAnalyzerViolation",
                    "SyntaxError",
                    $Failures))
                }
              }
            }
          }
          '

      - powershell: |
          Import-Module Pester

          $Options = @{
              Path = Convert-Path ".\Tests"
              OutputFormat = "NUnitXml"
              OutputFile = Join-Path '$(Common.TestResultsDirectory)' 'Test-$(Build.SourceVersion).xml'
          }

          if ($CodeCoverage = "$(Build.ArtifactStagingDirectory)") {
              $Options.CodeCoverage = Get-ChildItem $CodeCoverage -Recurse -Include *.psm1, *.ps1 | Convert-Path
              $Options.CodeCoverageOutputFile = '$(Common.TestResultsDirectory)/Coverage-$(Build.SourceVersion).xml'
          }

          Write-Host $($Options | Out-String)
          if (!$PSVersionTable.OS) {
              $PSVersionTable.OS = [System.Environment]::OSVersion
          }

          Write-Host "##vso[task.setvariable variable=PSPlatform]PowerShell $($PSVersionTable['PSVersion', 'OS'] -join ' on ')"
          Invoke-Pester @Options
      - task: PublishCodeCoverageResults@1
        displayName: Publish Code Coverage
        inputs:
          summaryFileLocation: '$(Common.TestResultsDirectory)/Coverage-$(Build.SourceVersion).xml'
          pathToSources: $(CodeCoverageRecurseDirectories)
          #failIfCoverageEmpty: true
        condition: succeededOrFailed()
      - task: PublishTestResults@2
        displayName: Publish Test Results
        inputs:
          testResultsFormat: NUnit
          testResultsFiles: '$(Common.TestResultsDirectory)/Test-$(Build.SourceVersion).xml'
          buildPlatform: $(PSPlatform)
          #buildConfiguration: ${{ parameters.configurationName }}
          failTaskOnFailedTests: true
          testRunTitle: "Pester on $(PSPlatform)"
        condition: succeededOrFailed()
