# template
parameters:
- name: DocsPath
  type: string
  default: ''
- name: CleanDestination
  type: boolean
  default: true
- name: ArtifactName
  type: string
  default: ''
- name: FailOnTestFailure
  type: boolean
  default: true
- name: DefaultBranch
  type: string
  default: master
- name: DevDeploys
  type: boolean
  default: false
- name: BuildEngine
  type: string
  default: mkdocs
  values:
  - mkdocs
  - hugo
- name: AuthSetting
  type: string
  default: valid-user

jobs:
- job: build
  steps:
  - bash: |
      cat << EOF > .markdownlint-cli2.jsonc
      {
        "outputFormatters": [
          [ "markdownlint-cli2-formatter-junit", { "name": "$(Common.TestResultsDirectory)/Test-$(Build.SourceVersion).xml" } ],
          [ "markdownlint-cli2-formatter-default" ]
        ]
      }
      EOF

      if [ ${{ parameters.BuildEngine }} == 'mkdocs' ]
      then
        DOCSOURCE='docs'
      elif [ ${{ parameters.BuildEngine }} == 'hugo' ]
      then
        DOCSOURCE='content'
      else
       echo failure
       exit 1
      fi
      echo $DOCSOURCE

      cat .markdownlint-cli2.jsonc

      sudo npm install markdownlint-cli2 markdownlint-cli2-formatter-junit -g
      markdownlint-cli2 "$DOCSOURCE/**/*.md"
      MDLINT=$?
      echo "return code: $MDLINT"
      case $MDLINT in
        0 | 1)
          exit 0
          ;;
        *)
          exit $MDLINT
          ;;
      esac
    displayName: Run Markdownlint
  - task: PublishTestResults@2
    displayName: Publish Test Results
    inputs:
      testResultsFormat: JUnit
      testResultsFiles: '$(Common.TestResultsDirectory)/Test-$(Build.SourceVersion).xml'
      failTaskOnFailedTests: ${{ parameters.FailOnTestFailure }}
  - ${{ if eq(parameters.BuildEngine, 'mkdocs') }}:
    - template: build-mkdocs.yml
  - ${{ elseif eq(parameters.BuildEngine, 'hugo') }}:
    - template: build-hugo.yml
  - task: AzurePowerShell@5
    inputs:
      azureSubscription: 'docs-publish'
      ScriptType: 'InlineScript'
      Inline: |
        $context = Get-AzContext
        $graphToken = [Microsoft.Azure.Commands.Common.Authentication.AzureSession]::Instance.AuthenticationFactory.Authenticate($context.Account, $context.Environment, $context.Tenant.Id.ToString(), $null, [Microsoft.Azure.Commands.Common.Authentication.ShowDialog]::Never, $null, "https://graph.microsoft.com").AccessToken
        Connect-MgGraph -AccessToken $graphToken

        $auth = "${{ parameters.AuthSetting }}"
        # $auth = "valid-user"

        switch ($auth) {
            "valid-user" {
                $output = "Require valid-user"
            }
            "pass" {
                $output = "OIDCUnAuthAction pass"
            }
            default {
                $aadGroup = Get-MgGroup -Filter "DisplayName eq '$auth'"
                if (-not $aadGroup) {
                    throw "Group not found"
                }
                $servicePrincipalId = 'd23effd1-8b94-4b9c-85fb-a0a799d7ae50'
                $assignments = Get-MgServicePrincipalAppRoleAssignedTo -ServicePrincipalId $servicePrincipalId
                if ($aadGroup.Id -in $assignments.principalId) {
                    $output = "Require claim `"groups~$($aadGroup.Id)`""
                }
                else {
                    throw "Group not Valid"
                }
            }
        }
        Write-Host $output
        $output | Out-File "$(Build.ArtifactStagingDirectory)/.htaccess"
      azurePowerShellVersion: 'LatestVersion'
    displayName: Create htaccess

  # - bash: |
  #     FILE=.htaccess
  #     if test -f "$FILE"; then
  #       cp $FILE $(Build.ArtifactStagingDirectory)/
  #     fi
  #   displayName: copy htaccess
  - publish: $(Build.ArtifactStagingDirectory)
    artifact: ${{ coalesce(parameters.ArtifactName, variables['Build.DefinitionName']) }}
- ${{ if parameters.DevDeploys }}:
  - template: deploy-docs.yml
    parameters:
      DocsPath: ${{ variables['Build.DefinitionName'] }}
      CleanDestination: ${{ parameters.CleanDestination }}
      ArtifactName: ${{ coalesce(parameters.ArtifactName, variables['Build.DefinitionName']) }}
      Environment: Dev
      BuildCondition: and(succeeded(), eq(${{ parameters.DevDeploys }}, true), startsWith(variables['build.sourceBranchName'], 'dev'))
- template: deploy-docs.yml
  parameters:
    DocsPath: ${{ variables['Build.DefinitionName'] }}
    CleanDestination: ${{ parameters.CleanDestination }}
    ArtifactName: ${{ coalesce(parameters.ArtifactName, variables['Build.DefinitionName']) }}
    Environment: Tst
    BuildCondition: or(and(succeeded(), not(startsWith(variables['build.sourceBranchName'], 'dev')), eq(${{ parameters.DevDeploys }}, true)), and(succeeded(), eq(${{ parameters.DevDeploys }}, false)))
- template: deploy-docs.yml
  parameters:
    DocsPath: ${{ variables['Build.DefinitionName'] }}
    CleanDestination: ${{ parameters.CleanDestination }}
    ArtifactName: ${{ coalesce(parameters.ArtifactName, variables['Build.DefinitionName']) }}
    Environment: Prd
    BuildCondition: and(succeeded(), eq(variables['build.sourceBranchName'], '${{ parameters.DefaultBranch }}'))
